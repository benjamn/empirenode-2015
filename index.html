<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">

    <title>The importance of import and export</title>

    <meta name="description" content="The importance of import and export">
    <meta name="author" content="Ben Newman">

    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/benjamn.css" id="theme">
    <link rel="stylesheet" href="plugin/highlight/default.min.css">
    <link rel="stylesheet" type="text/css" href="css/overrides.css">

    <!-- Code syntax highlighting -->
    <link rel="stylesheet" href="lib/css/xcode.css">

    <script src="plugin/highlight/highlight.pack.js"></script>
  </head>

  <body>
    <img class="branding" src="img/meteor-logo-mark-black-on-transparent.png" />

    <div class="reveal">

      <!-- Any section element inside of this container is displayed as a slide -->
      <div class="slides">
        <section>
          <h1>
            The Importance of <code class="javascript">import</code>
            and <code class="javascript">export</code>
          </h1>
          <p>
            <div class="fragment">
              <br>
              <a target="_blank" href="mailto:ben@meteor.com">Ben Newman</a>
              (<a target="_blank" href="https://www.meteor.com">Meteor</a>)
              <br>
              <a target="_blank"
                 href="http://2015.empirenode.org">EmpireNode 2015</a>
              <br>
            </div>
            <br>
            <pre class="contact fragment">
{ <a target="_blank" href="http://github.com/benjamn">github</a>,
  <a target="_blank" href="http://twitter.com/benjamn">twitter</a>,
  <a target="_blank" href="http://instagram.com/benjamn">instagram</a>,
  <a target="_blank" href="http://facebook.com/benjamn">facebook</a>
}.com/benjamn
            </pre>
          </p>
        </section>

        <section>
          <code class="javascript block medium">
export * from
  <a href="http://benjamn.github.io/empirenode-2015">"http://benjamn.github.io/empirenode-2015"</a>
          </code>
        </section>

        <section>
          <h2>Let's talk about <code class="fragment javascript">eval</code></h2>
          <br>
          <p class="fragment">
            The mere presence of <code class="javascript">eval</code> in a
            function thwarts almost any kind of optimization or static
            analysis.
          </p>
          <p class="fragment">
            Most JavaScript programmers I know
            consider <code class="javascript">eval</code> more harmful
            than <code>goto</code>.
          </p>
          <p class="fragment">
            Heaven forbid a snippet of user input should end up in one of
            those strings!
          </p>
          <p class="fragment">
            There's no good way for transpilers to
            support <code class="javascript">eval</code>, so they
            basically don't even try.
          </p>
        </section>

        <section>
          <h2>
            As a community we have decided
            <span class="fragment">it is never acceptable to
            use <code class="javascript">eval</code>
            <span class="fragment"> when there is <em>any other way</em>
            to solve the problem.</span>
          </h2>
        </section>

        <section>
          <h2>
            And yet <span class="fragment">we
            use <code class="javascript">eval</code> all the time.</span>
          </h2>
          <p class="fragment">
            It hides behind many different abstractions:
            <br>
            <ul>
              <li class="fragment">
                <code class="xml">&lt;script src="http://..."&gt;&lt;/script&gt;</code>
              </li>
              <li class="fragment">
                <code class="xml">&lt;script&gt;...&lt;/script&gt;</code>
              </li>
              <li class="fragment">
                <code class="javascript">new Function("...")()</code>
              </li>
              <li class="fragment">
                <code class="javascript">require("vm").runInThisContext("...")</code>
              </li>
              <li class="fragment">
                <code class="xml">&lt;a href="javascript:..."&gt;Click me!&lt;/a&gt;</code>
              </li>
              <li class="fragment">
                <code class="xml">&lt;input type="button" value="No, me!"
       onclick="..." /&gt;</code>
              </li>
              <li class="fragment">
                <code class="javascript">setTimeout("...", 1000)</code>
              </li>
          </p>

        </section>

        <section>
          <h2>
            Nothing happens
          </h2>
          <h2 class="fragment">
            unless first
            <span class="fragment">an <code class="javascript">eval</code>.</span>
          </h2>
          <br>
          <p class="fragment">
            <em style="float:right">Carl Sandburg</em>
          </p>
        </section>

        <section>
          <h2>
            There is a<span class="fragment">n <code class="javascript">eval</code>
            in everything.</span><br>
          </h2>
          <h2 class="fragment">
            That's how <span class="fragment">the code gets in.</span>
          </h2>
          <br>
          <p class="fragment">
            <em style="float:right">Leonard Cohen</em>
          </p>
        </section>

        <section>
          <h2>
            There's no escaping <code class="javascript">eval</code>
          </h2>
          <br>
          <p class="fragment">
            But it can be tamed, <span class="fragment">and Node does this
            better than any other JavaScript platform,</span>
            <span class="fragment">thanks to <strong>CommonJS</strong>.</span>
          </p>
        </section>

        <section>
          <h2>CommonJS is great</h2>
          <ul>
            <li class="fragment">
              All code runs in a specific module scope.
            </li>
            <li class="fragment">
              Any given module runs at most
              once, <span class="fragment">the first time
              you <code>require</code> it.</span>
            </li>
            <li class="fragment">
              Module source code is loaded from static files, <span class="fragment">according to
              <a target="_blank"
              href="https://nodejs.org/api/modules.html#modules_modules">simple
              rules</a>.</span>
            </li>
            <li class="fragment">
              Module load order emerges naturally.
            </li>
            <li class="fragment">
              Module <code>exports</code> remain distinct.
            </li>
            <li class="fragment">
              Global scope stays clean.
            </li>
          </ul>
          <br>
          <p class="fragment">
            Once your code starts
            running, <span class="fragment"><em>you</em> get to make all
            the decisions about what additional code is allowed to run,
            <span class="fragment">and when.</span>
          </p>
        </section>

        <section>
          <h2>
            Has CommonJS won?
          </h2>
          <br>
          <p class="fragment">
            From the perspective of Node and NPM,<br>
            <span class="fragment">it certainly seems so.</span>
          </p>
          <p class="fragment">
            But what about code running in browsers?
          </p>
          <p class="fragment">
            Is "winning" really all we care about?
          </p>
          <p class="fragment">
            Can we do better?
          </p>
        </section>

        <section>
          <h1>What's wrong with CommonJS?</h1>
        </section>

        <section class="full_height">
          <h2>Problem 1: <span class="fragment">How code is loaded</a></h2>
          <br>
          <p class="fragment">
            Node has it easy. <span class="fragment">Just ask the file
            system!</span>
          </p>
          <p class="fragment">
            Not so simple or efficient to do hundreds of synchronous HTTP
            requests over the network.
          </p>
          <p class="fragment">
            Instead, there has to be a way to deliver <em>bundles</em> of
            code to the client.<span class="fragment">*</span>
          </p>
          <br>
          <p class="fragment">
            <em>* Bundling woes deserve a talk of their own.<br>
              <a href="https://medium.com/@trek/last-week-i-had-a-small-meltdown-on-twitter-about-npms-future-plans-around-front-end-packaging-b424dd8d367a"
                 target="_blank">Listen</a> to
              <a target="_blank" href="https://twitter.com/trek">Trek Glowacki</a>.
            </em>
          </p>
        </section>

        <section>
          <h2>Problem 2: <span class="fragment">Dependency cycles</span></h2>
          <br>
          <ul>
            <li class="fragment">
              Not forbidden!
            </li>
            <li class="fragment">
              Relatively simple
              <a href="https://nodejs.org/api/modules.html#modules_cycles"
                 target="_blank">resolution policy</a>.
            </li>
            <li class="fragment">
              Extremely brittle, especially in large codebases.
            </li>
            <li class="fragment">
              Parable: <a href="https://github.com/facebook/react/commit/2ee66262db9fb91b0d0e9d64cefeb223074f8e05?diff=split"
                          target="_blank"><code>ReactMount</code> + <code>ReactID</code></a>
            </li>
            <li class="fragment">
              Lesson: you might think you can simply forbid cycles, but
              modularity will suffer.
            </li>
          </ul>
        </section>

        <section>
          <h2>Example: load order brittleness</h2>
          <!-- TODO -->
        </section>

        <section>
          <h2>
            Problem 3: <span class="fragment">
              <code class="javascript">exports</code> vs.
              <code class="javascript">module.exports</code>
            </span>
          </h2>
          <p class="fragment">
            Immediately returning a partially populated
            <code class="javascript">exports</code> object in case of
            circular dependencies would work so much better if
            that <code class="javascript">exports</code> object was
            guaranteed to become complete eventually.
          </p>
          <p class="fragment">
            But modules can change the very identity of
            <code class="javascript">exports</code> by reassigning
            the <code class="javascript">module.exports</code> property,
            <span class="fragment">rendering that partial
            <code class="javascript">exports</code> object totally
            irrelevant.</span>
          </p>
          <p class="fragment">
            Different modules that <code>require</code> the same module
            can end up with totally unrelated results!
          </p>
        </section>

        <section>
          <h2>Problem 4: <span class="fragment">Multiple exports</span></h2>
          <br>
          <p class="fragment">
            It's definitely nice
            that <code class="javascript">exports</code> objects can have
            multiple properties.
          </p>
          <p class="fragment">
            But it's nearly impossible to determine whether a certain
            property is actually used.
          </p>
          <p class="fragment">
            Not a huge problem on the server, but client bundlers like
            <a target="_blank"
               href="http://browserify.org">Browserify</a> and
            <a target="_blank"
               href="https://webpack.github.io">Webpack</a> end up
            including tons of dead code.
          </p>
        </section>

        <section>
          <h2>
            Self-discipline?
          </h2>
          <ul>
            <li class="fragment">
              Never assign to
              <code class="javascript">module.exports</code>,
              <span class="fragment">unless you are certain your module
              has no (circular) dependencies.</span>
            </li>
            <li class="fragment">
              Store references to imported <code>exports</code> objects:
              <code class="javascript block small">
var a = require("a"); // Mostly safe.
var foo = require("a").foo; // Dangerous!

exports.good = function (arg) {
  return a.foo("good", arg); // Uses the latest value of a.foo.
};

exports.bad = function (arg) {
  return foo("bad", arg); // Uses a stale value.
};</code>
            </li>
          </ul>
          <p class="fragment">
            There's nothing about CommonJS that helps you (or your
            teammates) keep this discipline.
          </p>
        </section>

        <section>
          <h2>
            CommonJS may be the most popular module system we have
          </h2>
          <br>
          <p class="fragment">
            But it's a shame that we're even talking about one module
            system winning a popularity contest.
          </p>
          <br>
          <p class="fragment">
            Almost every other language avoids this contest entirely, by
            providing <strong>a built-in module system</strong>, and most
            of them do it with a special syntax.
          </p>
        </section>

        <section>
          <h2>A native module system...</h2>
          <br>
          <ul>
            <li class="fragment">
              eases cooperation between authors and consumers of libraries,
            </li>
            <li class="fragment">
              eliminates the need for each library to provide its own
              module-loading system,
            </li>
            <li class="fragment">
              regularizes the structure of applications, and
            </li>
            <li class="fragment">
              allows the developer community to stop debating the merits of different
              code sharing mechanisms.
              <br><br>
            </li>
            <li class="fragment" style="list-style-type:none">
              <strong class="blink">
                <code class="xml">&lt;blink&gt;</code><br>
                <code>  </code>We have more interesting problems to solve!<br>
                <code class="xml">&lt;/blink&gt;</code>
              </strong>
            </li>
          </ul>
        </section>

        <section>
          <h3>
            A language without a native module system is a language in
            which no one is ever quite sure how to share their code with the
            widest possible audience.
          </h3>
        </section>

        <section>
          <h3>
            Betting on the wrong best practice (CommonJS? AMD? UMD?) is a
            recipe for obscurity, while reverting to the simplest common
            denominator (global variables) feels like giving up.
          </h3>
        </section>

        <section>
          <h2>
            And that's why the new ECMAScript 2015
            <code class="javascript">import</code>
            and <code class="javascript">export</code> statements are so
            vitally important.
          </h2>
        </section>

        <section>
          <h2>
            A native module system would be a huge
            relief <span class="fragment">even if it was more restrictive
            than CommonJS!</span>
          </h2>
          <br>
          <p class="fragment">
            The Go module system simply forbids circular dependencies.
          </p>
          <p class="fragment">
            That's one solution.
          </p>
          <p class="fragment">
            If you don't like it, don't use Go.
          </p>
        </section>

        <section>
          <h3>
            But in fact the ES2015 module system was designed with all the
            strengths and weaknesses of CommonJS in mind
          </h3>
          <br>
          <p class="fragment">
            Thanks to the hard work and cleverness of people like
            <a target="_blank"
               href="https://twitter.com/littlecalculist">Dave Herman</a>,
            <span class="javascript">ES2015 modules solve or at least
            mitigate all four of the problems I mentioned earlier.
          </p>
        </section>

        <section class="full_height">
          <h2>So how does it work?</h2>
          <br>
          <p class="fragment">
            At first glance, the
            ES2015 <code class="javascript">import</code> statement looks
            pretty similar to a destructuring variable declaration:
          </p>
          <div class="align-left"><code class="fragment javascript block small">
// What's the difference?
let {readFile, writeFile} = require("fs");
import {readFile, writeFile} from "fs";






</code></div>
        </section>

        <section class="full_height">
          <h2>So how does it work?</h2>
          <br>
          <p>
            At first glance, the
            ES2015 <code class="javascript">import</code> statement looks
            pretty similar to a destructuring variable declaration:
          </p>
          <div class="align-left"><code class="javascript block small">
// What's the difference?
let {readFile, writeFile} = require("fs");
import {readFile, writeFile} from "fs";

export function ensureTrailingNewline(path, callback) {
  readFile(path, "utf8", (err, text) => {
    if (err) callback(err);
    else writeFile(path, text.replace(/\n*$/, "\n"), callback);
  });
}</code></div>
        </section>

        <section class="full_height">
          <h2>So how does it work?</h2>
          <br>
          <p>
            At first glance, the
            ES2015 <code class="javascript">import</code> statement looks
            pretty similar to a destructuring variable declaration:
          </p>
          <div class="align-left"><code class="javascript block small">
// The destructuring version:
let {readFile, writeFile} = require("fs");


export function ensureTrailingNewline(path, callback) {
  readFile(path, "utf8", (err, text) => {
    if (err) callback(err);
    else writeFile(path, text.replace(/\n*$/, "\n"), callback);
  });
}</code></div>
        </section>

        <section class="full_height">
          <h2>So how does it work?</h2>
          <br>
          <p>
            At first glance, the
            ES2015 <code class="javascript">import</code> statement looks
            pretty similar to a destructuring variable declaration:
          </p>
          <div class="align-left"><code class="javascript block small">
// The destructuring version:
let readFile = require("fs").readFile;
let writeFile = require("fs").writeFile;

export function ensureTrailingNewline(path, callback) {
  readFile(path, "utf8", (err, text) => {
    if (err) callback(err);
    else writeFile(path, text.replace(/\n*$/, "\n"), callback);
  });
}</code></div>
        </section>

        <section class="full_height">
          <h2>So how does it work?</h2>
          <br>
          <p>
            At first glance, the
            ES2015 <code class="javascript">import</code> statement looks
            pretty similar to a destructuring variable declaration:
          </p>
          <div class="align-left"><code class="javascript block small">
// This has all the problems as our earlier example!
let readFile = require("fs").readFile;
let writeFile = require("fs").writeFile;

export function ensureTrailingNewline(path, callback) {
  readFile(path, "utf8", (err, text) => {
    if (err) callback(err);
    else writeFile(path, text.replace(/\n*$/, "\n"), callback);
  });
}</code></div>
        </section>

        <section class="full_height">
          <h2>So how does it work?</h2>
          <br>
          <p>
            At first glance, the
            ES2015 <code class="javascript">import</code> statement looks
            pretty similar to a destructuring variable declaration:
          </p>
          <div class="align-left"><code class="javascript block small">
// This has all the problems as our earlier example!
let foo = require("a").foo;


export function ensureTrailingNewline(path, callback) {
  readFile(path, "utf8", (err, text) => {
    if (err) callback(err);
    else writeFile(path, text.replace(/\n*$/, "\n"), callback);
  });
}</code></div>
        </section>

        <section class="full_height">
          <h2>So how does it work?</h2>
          <br>
          <p>
            At first glance, the
            ES2015 <code class="javascript">import</code> statement looks
            pretty similar to a destructuring variable declaration:
          </p>
          <div class="align-left"><code class="javascript block small">
// The ES2015 version:
import {readFile, writeFile} from "fs";


export function ensureTrailingNewline(path, callback) {
  readFile(path, "utf8", (err, text) => {
    if (err) callback(err);
    else writeFile(path, text.replace(/\n*$/, "\n"), callback);
  });
}</code></div>
        </section>

        <section class="full_height">
          <h2>So how does it work?</h2>
          <br>
          <p>
            At first glance, the
            ES2015 <code class="javascript">import</code> statement looks
            pretty similar to a destructuring variable declaration:
          </p>
          <div class="align-left"><code class="javascript block small">
// The ES2015 version:
const _fs = require("fs");


export function ensureTrailingNewline(path, callback) {
  readFile(path, "utf8", (err, text) => {
    if (err) callback(err);
    else writeFile(path, text.replace(/\n*$/, "\n"), callback);
  });
}</code></div>
        </section>

        <section class="full_height">
          <h2>So how does it work?</h2>
          <br>
          <p>
            At first glance, the
            ES2015 <code class="javascript">import</code> statement looks
            pretty similar to a destructuring variable declaration:
          </p>
          <div class="align-left"><code class="javascript block small">
// The ES2015 version:
const _fs = require("fs");


export function ensureTrailingNewline(path, callback) {
  _fs.readFile(path, "utf8", (err, text) => {
    if (err) callback(err);
    else _fs.writeFile(path, text.replace(/\n*$/, "\n"), callback);
  });
}</code></div>
        </section>

        <section class="full_height">
          <h2>So how does it work?</h2>
          <br>
          <p>
            At first glance, the
            ES2015 <code class="javascript">import</code> statement looks
            pretty similar to a destructuring variable declaration:
          </p>
          <div class="align-left"><code class="javascript block small">
// The ES2015 version:
const _fs = require("fs");

export function ensureTrailingNewline(path, callback) {
  _fs.readFile(path, "utf8", (err, text) => {
    if (err) callback(err);
    else _fs.writeFile(path, text.replace(/\n*$/, "\n"), callback);
  });
}</code></div>
          <p class="fragment">
            <a target="_blank"
               href="https://www.npmjs.com/package/graceful-fs">Popular</a>
            package for which this matters:
            <a target="_blank"
               class="fragment"
               href="https://github.com/isaacs/node-graceful-fs/blob/4f6a7e8a01/README.md#global-patching"><code>graceful-fs</code></a>
          </p>
        </section>

        <section class="full_height">
          <h2>
            What about <code class="javascript">module.exports</code>?
          </h2>
          <p class="fragment">
            ES2015 modules can define
            a <code class="javascript">default</code> exported value:
          </p>
          <div class="align-left">
            <code class="javascript fragment block small">
// In abc.js:
export default function a() {...}











            </code>
          </div>
        </section>

        <section class="full_height">
          <h2>
            What about <code class="javascript">module.exports</code>?
          </h2>
          <p>
            ES2015 modules can define
            a <code class="javascript">default</code> exported value:
          </p>
          <div class="align-left">
            <code class="javascript block small">
// In abc.js:
export default function a() {...}



// In d.js:
import a from "./abc";






            </code>
          </div>
        </section>

        <section class="full_height">
          <h2>
            What about <code class="javascript">module.exports</code>?
          </h2>
          <p>
            ES2015 modules can define
            a <code class="javascript">default</code> exported value:
          </p>
          <div class="align-left">
            <code class="javascript block small">
// In abc.js:
export default function () {...}



// In d.js:
import a from "./abc";






            </code>
          </div>
        </section>

        <section class="full_height">
          <h2>
            What about <code class="javascript">module.exports</code>?
          </h2>
          <p>
            ES2015 modules can define
            a <code class="javascript">default</code> exported value:
          </p>
          <div class="align-left">
            <code class="javascript block small">
// In abc.js:
export default function () {...}



// In d.js:
import a from "./abc";
import a1 from "./abc";





            </code>
          </div>
        </section>

        <section class="full_height">
          <h2>
            What about <code class="javascript">module.exports</code>?
          </h2>
          <p>
            ES2015 modules can define
            a <code class="javascript">default</code> exported value:
          </p>
          <div class="align-left">
            <code class="javascript block small">
// In abc.js:
export default function () {...}
export function b() {...}


// In d.js:
import a from "./abc";
import a1 from "./abc";





            </code>
          </div>
        </section>

        <section class="full_height">
          <h2>
            What about <code class="javascript">module.exports</code>?
          </h2>
          <p>
            ES2015 modules can define
            a <code class="javascript">default</code> exported value:
          </p>
          <div class="align-left">
            <code class="javascript block small">
// In abc.js:
export default function () {...}
export function b() {...}
export const c = 299792458;

// In d.js:
import a from "./abc";
import a1 from "./abc";





            </code>
          </div>
        </section>

        <section class="full_height">
          <h2>
            What about <code class="javascript">module.exports</code>?
          </h2>
          <p>
            ES2015 modules can define
            a <code class="javascript">default</code> exported value:
          </p>
          <div class="align-left">
            <code class="javascript block small">
// In abc.js:
export default function () {...}
export function b() {...}
export const c = 299792458;

// In d.js:
import a from "./abc";
import a1 from "./abc";
import {b, c} from "./abc";




            </code>
          </div>
        </section>

        <section class="full_height">
          <h2>
            What about <code class="javascript">module.exports</code>?
          </h2>
          <p>
            ES2015 modules can define
            a <code class="javascript">default</code> exported value:
          </p>
          <div class="align-left">
            <code class="javascript block small">
// In abc.js:
export default function () {...}
export function b() {...}
export const c = 299792458;

// In d.js:
import a from "./abc";
import a1 from "./abc";
import {b, c} from "./abc";
import {b as bee, c as lightSpeed} from "./abc";



            </code>
          </div>
        </section>

        <section class="full_height">
          <h2>
            What about <code class="javascript">module.exports</code>?
          </h2>
          <p>
            ES2015 modules can define
            a <code class="javascript">default</code> exported value:
          </p>
          <div class="align-left">
            <code class="javascript block small">
// In abc.js:
export default function () {...}
export function b() {...}
export const c = 299792458;

// In d.js:
import a from "./abc";
import a1 from "./abc";
import {b, c} from "./abc";
import {b as bee, c as lightSpeed} from "./abc";
import {default as a2} from "./abc";


            </code>
          </div>
        </section>

        <section class="full_height">
          <h2>
            What about <code class="javascript">module.exports</code>?
          </h2>
          <p>
            ES2015 modules can define
            a <code class="javascript">default</code> exported value:
          </p>
          <div class="align-left">
            <code class="javascript block small">
// In abc.js:
export default function () {...}
export function b() {...}
export const c = 299792458;

// In d.js:
import a from "./abc";
import a1 from "./abc";
import {b, c} from "./abc";
import {b as bee, c as lightSpeed} from "./abc";
import {default as a2} from "./abc";
import {default as a3, b, c} from "./abc";

            </code>
          </div>
        </section>

        <section class="full_height">
          <h2>
            What about <code class="javascript">module.exports</code>?
          </h2>
          <p>
            ES2015 modules can define
            a <code class="javascript">default</code> exported value:
          </p>
          <div class="align-left">
            <code class="javascript block small">
// In abc.js:
export default function () {...}
export function b() {...}
export const c = 299792458;

// In d.js:
import a from "./abc";
import a1 from "./abc";
import {b, c} from "./abc";
import {b as bee, c as lightSpeed} from "./abc";
import {default as a2} from "./abc";
import {default as a3, b, c} from "./abc";
import a4, {b, c} from "./abc";
            </code>
          </div>
          <p class="fragment">
            Default and named exports, together at last!
          </p>
        </section>

        <section>
          <h3>
            You might even say <span class="fragment">the ES2015 module
            system enforces the discipline I outlined
            earlier...</span> <span class="fragment">which means it doesn't
            have to be <em>self</em>-discipline.</span>
          </h2>
          <br>
          <p class="fragment">
            And that makes all the difference.
          </p>
        </section>

        <section class="full_height">
          <h2>Multiple exports?</h2>
          <p class="fragment">
            ES2015 <code class="javascript">export</code> statements must
            appear only at the top level of a
            module, <span class="fragment">and must have one of the
            following forms</span><span class="fragment">&mdash;all of
            which have names:</span>
          </p>
          <ul>
            <li class="fragment">
              <code class="javascript medium">export var a = ...;</code>
            </li>
            <li class="fragment">
              <code class="javascript medium">export let b = ...;</code>
            </li>
            <li class="fragment">
              <code class="javascript medium">export const c = ...;</code>
            </li>
            <li class="fragment">
              <code class="javascript medium">export function d() {...}</code>
            </li>
            <li class="fragment">
              <code class="javascript medium">export function* e() {...}</code>
            </li>
            <li class="fragment">
              <code class="javascript medium">export class F {...}</code>
            </li>
            <li class="fragment">
              <code class="javascript medium">export default <em>expression</em>;</code>
            </li>
            <li class="fragment">
              <code class="javascript medium">export {a, b, c, d, e as genFn, F};</code>
            </li>
          </ul>
        </section>

        <section class="full_height">
          <h2>Multiple exports?</h2>
          <p class="fragment">
            ES2015 <code class="javascript">import</code> statements
            provide no way to obtain the <code>exports</code> object
            itself.
          </p>
          <p class="fragment">
            In fact, there's no reason an implementation of ES2015 modules
            needs to represent exports using an object.
          </p>
          <p class="fragment">
            That's just an implementation detail that happens to be
            convenient if you're compiling for an environment that
            supports CommonJS.
          </p>
          <p class="fragment">
            This makes it possible to determine, <a target="_blank"
            href="http://calculist.org/blog/2012/06/29/static-module-resolution/">statically</a>,
            for any form of <code class="javascript">import</code>
            statement, exactly which exports it does and doesn't care
            about.
          </p>
        </section>

        <section>
          <h2>
            Detailed
            <a href="http://www.2ality.com/2014/09/es6-modules-final.html"
               target="_blank">explanation</a> by <a target="_blank"
               href="https://twitter.com/rauschma">Axel Rauschmayer</a> of
               every variation of <code class="javascript">import</code>
               and <code class="javascript">export</code> syntax.
          </h2>
        </section>

        <section class="external_iframe">
          <h2>
            <a target="_blank" href="http://rollupjs.org/">Rollup</a>
            <span class="fragment">(<a target="_blank"
                href="https://twitter.com/Rich_Harris">Rich Harris</a>)</span>
          </h2>
          <p class="fragment">
            <em>A tool from the future.</em>
          </p>
          <iframe class="fragment"src="http://rollupjs.org"></iframe>
        </section>

        <section>
          <h2>
            But enough about the future.
          </h2>
        </section>

        <section class="full_height">
          <h2>How can you use ES2015 modules today?</h2>
          <p class="fragment">
            I would love to tell you, "Just use
            Meteor!" <span class="fragment">And that will soon be the
            case.</span>
          </p>
          <p class="fragment">
            Until Meteor 1.3 is released, I've put together
            <a href="https://www.npmjs.com/package/jsnext-skeleton"
            target="_blank">a skeleton NPM package</a> that you can clone
            and modify, or just use as inspiration:
          </p>
          <code class="fragment bash block small">
git clone <a target="_blank" href="https://github.com/benjamn/jsnext-skeleton">https://github.com/benjamn/jsnext-skeleton</a>.git
cd jsnext-skeleton
npm install
npm test</code>
          <p class="fragment">
            Try it, break it, republish it, submit pull requests!
          </p>
        </section>

        <section class="full_height">
          <h2>How can you use ES2015 modules today?</h2>
          <p class="fragment">
            Some stuff you can do with this skeleton package:
          </p>
          <ul>
            <li class="fragment">
              write ES2015 in the <code>src/</code> directory,
            </li>
            <li class="fragment">
              transpile from <code>src/</code> into <code>lib/</code>
              using an <code>npm</code> prepublish command,
            </li>
            <li class="fragment">
              run <a target="_blank"
              href="https://www.npmjs.com/package/mocha"><code>mocha</code></a>
              tests against code from both <code>src/</code>
              and <code>lib/</code>, ensuring identical output, and
            </li>
            <li class="fragment">
              publish both <code>lib/</code> and <code>src/</code> code to
              NPM, so everything Just Works&#8482; but also ES2015-aware
              tools like Rollup can work their magic.
            </li>
          </ul>
        </section>

        <section>
          <h3>
            Soon you'll be publishing both ES2015 and CommonJS to NPM,
            <span class="fragment">but what use are either of those formats
            to folks who really just want a <code>.js</code> file they can
            load with a
            <code class="xml">&lt;script&gt;</code> tag on a web
            page?</span>
          </h3>
        </section>

        <section>
          <h2>To bundle, or not to bundle?</h2>
          <p class="fragment">
            <strong>Some say:</strong> <span class="fragment">bundles need
            to be created at publish time, so that library authors can deal with
            bundling errors, instead of burdening the consumer.</span>
          </p>
          <p class="fragment">
            <strong>Others say:</strong> <span class="fragment">if library
            authors bundle in their dependencies, consumers of multiple
            libraries may end up with conflicting copies of those
            dependencies.</span>
          </p>
          <p class="fragment">
            <strong>Still others:</strong> <span class="fragment">if we
            could all just use the same language for writing modules, then
            our bundling tools would have a much easier job.</span>
          </p>
        </section>

        <section>
          <h2>Here's where I brag about Meteor</h2>
          <p class="fragment">
            Meteor's build system takes care of pretty much every aspect
            of bundling for you. <span class="fragment">Only binary
            dependencies need to be published for multiple
            architectures.</span>
          </p>
          <p class="fragment">
            Meteor uses an <a target="_blank"
            href="https://www.meteor.com/version-solver">optimizing
            constraint solver</a> (compiled from C++ to JS
            using <a target="_blank"
            href="http://kripken.github.io/emscripten-site">Emscripten</a>)
            to ensure compatible package versions.
          </p>
          <p class="fragment">
            Meteor will support ES2015 modules in version
            1.3, <span class="fragment">if I have anything to do with
            it.</span> <span class="fragment">And I have everything to do
            with it.</span> <span class="fragment">No, seriously, you know
            who to blame if modules don't make it into the 1.3 release.</span>
          </p>
        </section>

        <section>
          <h2>My feeble pleas:</h2>
          <br>
          <ul>
            <li class="fragment">
              Start writing ES2015 modules sooner rather than later,
              assuming I have persuaded you that they are awesome.
            </li>
            <li class="fragment">
              No need for funny file
              extensions. <span class="fragment">ES2015 is
              <code>.js</code>.</span>
            </li>
            <li class="fragment">
              Publish your source files to NPM, in addition to your
              CommonJS files, so that sophisticated tools can make use of
              them.
            </li>
            <li class="fragment">
              Add a
              <a href="https://github.com/rollup/rollup/wiki/jsnext:main"
                 target="_blank"><code>jsnext:main</code></a> property to
                 your <code>package.json</code>, so the tools know where
                 to look.
            </li>
          </ul>
        </section>

        <section>
          <h2>
            Better yet, <span class="fragment">if you want to help me
            submit automated pull requests to every Node project on
            GitHub,</span> <span class="fragment">find me after this
            talk!</span>
          </h2>
          <br>
          <pre class="contact fragment">
     { <a target="_blank" href="http://github.com/benjamn">github</a>,
       <a target="_blank" href="http://twitter.com/benjamn">twitter</a>,
       <a target="_blank" href="http://instagram.com/benjamn">instagram</a>,
       <a target="_blank" href="http://facebook.com/benjamn">facebook</a>
     }.com/benjamn

ben@{<a href="mailto:ben@benjamn.com">benjamn</a>,<a href="mailto:ben@meteor.com">meteor</a>}.com
            </pre>
        </section>

        <section data-background="img/wires.jpg">
          <h1 class="thanks">Thanks!</h1>
        </section>
      </div>
    </div>

    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.js"></script>
    <script src="js/init.js"></script>
  </body>
</html>
