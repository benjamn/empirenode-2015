<!doctype html>
<html lang="en">

  <head>
    <meta charset="utf-8">

    <title>Why Fibers Make Sense For Meteor</title>

    <meta name="description" content="Why Fibers Make Sense For Meteor">
    <meta name="author" content="Ben Newman">

    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/benjamn.css" id="theme">
    <link rel="stylesheet" href="plugin/highlight/default.min.css">
    <link rel="stylesheet" type="text/css" href="css/overrides.css">

    <!-- Code syntax highlighting -->
    <link rel="stylesheet" href="lib/css/xcode.css">

    <script src="plugin/highlight/highlight.min.js"></script>

    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>

    <!--[if lt IE 9]>
    <script src="lib/js/html5shiv.js"></script>
    <![endif]-->
  </head>

  <body>
    <img class="branding" src="img/meteor-logo-mark-black-on-transparent.png" />

    <div class="reveal">

      <!-- Any section element inside of this container is displayed as a slide -->
      <div class="slides">
        <section data-background="img/goto/intro.png"
                 data-background-size="70%">
        </section>

        <section>
          <h1>Why Fibers Make Sense For Meteor</h1>
          <p>
            <a target="_blank" href="mailto:ben@meteor.com">Ben Newman</a>
            (<a target="_blank" href="https://www.meteor.com">Meteor</a>)<br>
            <!-- <code><a target="_blank" href="http://gotocon.com/chicago-2015">GOTO</a>;</code> -->
            <a target="_blank"
               href="http://gotocon.com/chicago-2015/presentation/Why%20Fibers%20Make%20Sense%20For%20Meteor">11 May 2015</a><br>
            <pre class="contact">
         { <a target="_blank" href="http://github.com/benjamn">github</a>,
           <a target="_blank" href="http://twitter.com/benjamn">twitter</a>,
           <a target="_blank" href="http://instagram.com/benjamn">instagram</a>,
           <a target="_blank" href="http://facebook.com/benjamn">facebook</a>
         }.com/benjamn


<a target="_blank"
   href="http://benjamn.github.io/goto2015-talk">benjamn.github.io/goto2015-talk</a></pre>
          </p>
        </section>

        <section>
          <h2>
            How do<br>
            languages<br>
            change?
          </h2>
        </section>

        <section>
          <h2>
            How do<br>
            programming languages<br>
            change?
          </h2>
        </section>

        <section>
          <h2>
            How do<br>
            natural languages<br>
            change?
          </h2>
        </section>

        <section>
          <h2>
            How can<br>
            JavaScript<br>
            change?
          </h2>
        </section>

        <section>
          <h2>
            &ldquo;The Web is a brutal,<br>
            shortest-path, Worse-is-Better
            evolving system.&rdquo;
          </h2>
        </section>

        <section>
          <h2>
            JavaScript is finally<br>
            becoming the language<br>
            we want.
          </h2>
        </section>

        <section>
          <h2>
            Many new features can<br>
            be <em>simulated</em> without any<br>
            changes to the language.
          </h2>
          <p class="fragment">
            <code class="javascript block">
// ES6 Arrow function
[1, 3, 21, 10].sort((a, b) => a - b)
</code>
          </p>
          <p class="fragment">
            <code class="javascript block">
// ES5 Function expression
[1, 3, 21, 10].sort(function (a, b) {
  return a - b;
})
</code>
          </p>
        </section>

        <section>
          <h2>
            But not everything!
          </h2>
        </section>

        <section>
          <h2>
            Today I want to talk about a powerful feature that cannot be
            simulated in any reasonable way.
          </h2>
          <br>
          <p class="fragment">
            A &ldquo;reasonable&rdquo; translation must produce code that
            is readable, debuggable, and recognizable as JavaScript,
            rather than (say) generating bytecode that runs on a VM
            implemented in JavaScript.
          </p>
        </section>

        <section>
          <h2>
            And you can use this feature in Meteor today!
          </h2>
        </section>

        <section>
          <h1>
            Coroutines<span class="fragment">
              (<a target="_blank"
                  href="https://github.com/laverdet/node-fibers">Fibers</a>)
            </span>
          </h1>
          <br>
          <p class="fragment">
            JavaScript has a strict <b>run-to-completion</b> execution
            model,<span class="fragment"> meaning that the current call
            stack must unwind completely before any other events can be
            handled by the event loop.</span>
          </p>
          <p class="fragment">
            If you've ever wished you could simply <em>pause</em> the
            current call stack,<span class="fragment"> let some other
            events run,<span class="fragment"> and then later resume where
            you left off,<psan class="fragment"> that's exactly what
            coroutines are for.</span></span></span>
          </p>
        </section>

        <section>
          <h1>
            Coroutines
            (<a target="_blank"
                href="https://github.com/laverdet/node-fibers">Fibers</a>)
          </h1>
          <br>
          <code class="javascript block fragment left">
new Fiber(function () {
  console.log("before");
  sleep(1000);
  console.log("after");
}).run();</code>
          <code class="javascript block fragment right">
function sleep(ms) {
  var fiber = Fiber.current;
  setTimeout(fiber.run, ms);
  Fiber.yield();
}</code>
        </section>

        <section>
          <h1>
            Coroutines
            (<a target="_blank"
                href="https://github.com/laverdet/node-fibers">Fibers</a>)
          </h1>
          <br>
          <code class="javascript block left">
new Fiber(function () {
  console.log("before");
  sleep(1000); // Seemingly synchronous!
  console.log("after");
}).run();</code>
          <code class="javascript block right">
function sleep(ms) {
  var fiber = Fiber.current;
  setTimeout(fiber.run, ms);
  Fiber.yield();
}</code>
        </section>

        <section class="fixed-height">
          <h2>
            Many other languages<br>
            support coroutines!
          </h2>
          <br>
          <p class="fragment">
            Aikido, AngelScript, BCPL, Pascal, BETA, BLISS, C#, ChucK, D,
            Dynamic C, Erlang, F#, Factor, GameMonkey Script, Go, Haskell,
            High Level Assembly, Icon, Io, Julia, Limbo, Lua, Lucid, µC++,
            MiniD, Modula-2, Nemerle, Perl, PHP, Picolisp, Prolog, Python,
            Ruby, Rust, Sather, Scheme, Self, Simula 67, Squirrel,
            Stackless Python, SuperCollider, Tcl, urbiscript
          </p>
        </section>

        <section class="fixed-height">
          <h2>
            Many other languages<br>
            support coroutines!
          </h2>
          <br>
          <p>
            Aikido, AngelScript, BCPL, Pascal, BETA, BLISS, <b>C#</b>,
            ChucK, <b>D</b>, Dynamic C, <b>Erlang</b>, F#, Factor,
            GameMonkey Script, <b>Go</b>, <b>Haskell</b>, High Level
            Assembly, Icon, Io, <b>Julia</b>, Limbo, <b>Lua</b>, Lucid,
            µC++, MiniD, Modula-2, Nemerle, <b>Perl</b>, PHP, Picolisp,
            Prolog, <b>Python</b>, <b>Ruby</b>, <b>Rust</b>,
            Sather, <b>Scheme</b>, <b>Self</b>, Simula 67, Squirrel,
            Stackless Python, SuperCollider, Tcl, urbiscript
          </p>
        </section>

        <section>
          <h2>
            Why not JavaScript?
          </h2>
        </section>

        <section class="external_iframe">
          <h2>Dave Herman (Mozilla, TC39):</h2>
          <iframe class="fragment"
                  src="http://calculist.org/blog/2011/12/14/why-coroutines-wont-work-on-the-web"></iframe>
        </section>

        <section>
          <h2>
            Programming language design is as much about saying
            &ldquo;no&rdquo; to tempting features as it is about saying
            &ldquo;yes.&rdquo;
          </h2>
        </section>

        <section>
          <h2>
            If we can agree that making asynchronous programming easier is
            important for the future of JavaScript,<span class="fragment">
            and TC39 is not interested in
            coroutines,<span class="fragment"> then what other remedy do
            they have in mind?</span></span>
          </h2>
        </section>

        <section>
          <h1>
            <code class="javascript">async</code> and
            <code class="javascript">await</code>
          </h1>
          <div class="align-left">
            <code class="javascript small block fragment">
async function createUser(name) {
  let response = await users.insert({ name: name });
  return await users.findOne(response._id);
}</code>
            <code class="javascript small block fragment">
async function getOrCreateUser(name) {
  let user = await users.findOne({ name: name });
  return user || await createUser(name);
}</code>
            <code class="javascript small block fragment">
getOrCreateUser("ben").then(function (ben) {
  console.log(ben.name);
});</code>
          </div>
          <p class="fragment">
            Planned for ES7, available today via <a target="_blank"
            href="https://github.com/facebook/regenerator">Regenerator</a>
            (ES3+) or <a target="_blank"
            href="https://www.npmjs.com/package/es7-async-await">es7-async-await</a>
            (ES6+).
          </p>
        </section>

        <section>
          <section>
            <h2>
              Let's try that with pure promises...
            </h2>
            <div class="align-left">
              <code class="javascript small block fragment">
async function createUser(name) {
  let response = await users.insert({ name: name });
  return await users.findOne(response._id);
}

async function getOrCreateUser(name) {
  let user = await users.findOne({ name: name });
  return user || await createUser(name);
}

getOrCreateUser("ben").then(function (ben) {
  console.log(ben.name);
});

              </code>
            </div>
            <p class="hidden">
              Slightly more boilerplate, though imagine
              if <code class="javascript">await</code>
              appeared inside a loop!
            </p>
          </section>

          <section>
            <h2>
              Let's try that with pure promises...
            </h2>
            <div class="align-left">
              <code class="javascript small block">
function createUser(name) {
  return users.insert({ name: name }).then(function (response) {
    return users.findOne(response._id);
  });
}

async function getOrCreateUser(name) {
  let user = await users.findOne({ name: name });
  return user || await createUser(name);
}

getOrCreateUser("ben").then(function (ben) {
  console.log(ben.name);
});
              </code>
            </div>
            <p class="hidden">
              Slightly more boilerplate, though imagine
              if <code class="javascript">await</code>
              appeared inside a loop!
            </p>
          </section>

          <section>
            <h2>
              Let's try that with pure promises...
            </h2>
            <div class="align-left">
              <code class="javascript small block">
function createUser(name) {
  return users.insert({ name: name }).then(function (response) {
    return users.findOne(response._id);
  });
}

function getOrCreateUser(name) {
  return users.findOne({ name: name }).then(function (user) {
    return user || createUser(name);
  });
}

getOrCreateUser("ben").then(function (ben) {
  console.log(ben.name);
});</code>
            </div>
            <p class="fragment">
              Slightly more boilerplate, though imagine
              if <code class="javascript">await</code>
              appeared inside a loop!
            </p>
          </section>
        </section>

        <section>
          <section>
            <h2>
              What about callbacks?
            </h2>
            <div class="align-left">
              <code class="javascript small block fragment">
function createUser(name) {
  return users.insert({ name: name }).then(function (response) {
    return users.findOne(response._id);
  });
}

function getOrCreateUser(name) {
  return users.findOne({ name: name }).then(function (user) {
    return user || createUser(name);
  });
}








              </code>
            </div>
          </section>

          <section>
            <h2>
              What about callbacks?
            </h2>
            <div class="align-left">
              <code class="javascript small block">
function createUser(name, callback) {
  users.insert({ name: name }).then(function (response) {
    users.findOne(response._id).then(function (user) {
      callback(null, user);
    }, function (error) {
      callback(error);
    });
  }, function (error) {
    callback(error);
  });
}

function getOrCreateUser(name) {
  return users.findOne({ name: name }).then(function (user) {
    return user || createUser(name);
  });
}


              </code>
            </div>
          </section>

          <section>
            <h2>
              What about callbacks?
            </h2>
            <div class="align-left">
              <code class="javascript small block">
function createUser(name, callback) {
  users.insert({ name: name }).then(function (response) {
    users.findOne(response._id).then(function (user) {
      callback(null, user);
    }, function (error) {
      callback(error);
    });
  }, function (error) {
    callback(error);
  });
}

function getOrCreateUser(name, callback) {
  users.findOne({ name: name }).then(function (user) {
    if (user) callback(null, user);
    else createUser(name, callback);
  }, function (error) {
    callback(error);
  });
}</code>
            </div>
          </section>
        </section>

        <section>
          <h1>
            We've come so far!
          </h1>
        </section>

        <section>
          <h1>
            Can we do better?
          </h1>
        </section>

        <section>
          <section>
            <h2>
              If JavaScript had coroutines, we could
              implement <code class="javascript">async</code>
              and <code class="javascript">await</code> without any new
              syntax.
            </h2>
            <div class="align-left fragment">
              <code class="javascript small block">
async function createUser(name) {
  let response = await users.insert({ name: name });
  return await users.findOne(response._id);
}

async function getOrCreateUser(name) {
  let user = await users.findOne({ name: name });
  return user || await createUser(name);
}</code>
            </div>
            <p class="hidden">
              Just function calls!
            </p>
          </section>

          <section>
            <h2>
              If JavaScript had coroutines, we could
              implement <code class="javascript">async</code>
              and <code class="javascript">await</code> without any new
              syntax.
            </h2>
            <div class="align-left">
              <code class="javascript small block">
let createUser = async(function (name) {
  let response = await users.insert({ name: name });
  return await users.findOne(response._id);
});

async function getOrCreateUser(name) {
  let user = await users.findOne({ name: name });
  return user || await createUser(name);
}</code>
            </div>
            <p class="hidden">
              Just function calls!
            </p>
          </section>

          <section>
            <h2>
              If JavaScript had coroutines, we could
              implement <code class="javascript">async</code>
              and <code class="javascript">await</code> without any new
              syntax.
            </h2>
            <div class="align-left">
              <code class="javascript small block">
let createUser = async(function (name) {
  let response = await(users.insert({ name: name }));
  return await users.findOne(response._id);
});

async function getOrCreateUser(name) {
  let user = await users.findOne({ name: name });
  return user || await createUser(name);
}</code>
            </div>
            <p class="hidden">
              Just function calls!
            </p>
          </section>

          <section>
            <h2>
              If JavaScript had coroutines, we could
              implement <code class="javascript">async</code>
              and <code class="javascript">await</code> without any new
              syntax.
            </h2>
            <div class="align-left">
              <code class="javascript small block">
let createUser = async(function (name) {
  let response = await(users.insert({ name: name }));
  return await(users.findOne(response._id));
});

async function getOrCreateUser(name) {
  let user = await users.findOne({ name: name });
  return user || await createUser(name);
}</code>
            </div>
            <p class="hidden">
              Just function calls!
            </p>
          </section>

          <section>
            <h2>
              If JavaScript had coroutines, we could
              implement <code class="javascript">async</code>
              and <code class="javascript">await</code> without any new
              syntax.
            </h2>
            <div class="align-left">
              <code class="javascript small block">
let createUser = async(function (name) {
  let response = await(users.insert({ name: name }));
  return await(users.findOne(response._id));
});

let getOrCreateUser = async(function (name) {
  let user = await users.findOne({ name: name });
  return user || await createUser(name);
});</code>
            </div>
            <p class="hidden">
              Just function calls!
            </p>
          </section>

          <section>
            <h2>
              If JavaScript had coroutines, we could
              implement <code class="javascript">async</code>
              and <code class="javascript">await</code> without any new
              syntax.
            </h2>
            <div class="align-left">
              <code class="javascript small block">
let createUser = async(function (name) {
  let response = await(users.insert({ name: name }));
  return await(users.findOne(response._id));
});

let getOrCreateUser = async(function (name) {
  let user = await(users.findOne({ name: name }));
  return user || await createUser(name);
});</code>
            </div>
            <p class="hidden">
              Just function calls!
            </p>
          </section>

          <section>
            <h2>
              If JavaScript had coroutines, we could
              implement <code class="javascript">async</code>
              and <code class="javascript">await</code> without any new
              syntax.
            </h2>
            <div class="align-left">
              <code class="javascript small block">
let createUser = async(function (name) {
  let response = await(users.insert({ name: name }));
  return await(users.findOne(response._id));
});

let getOrCreateUser = async(function (name) {
  let user = await(users.findOne({ name: name }));
  return user || await(createUser(name));
});</code>
            </div>
            <p class="fragment">
              Just function calls!
            </p>
          </section>
        </section>

        <section>
          <section>
            <h2>How might these magical functions be implemented?</h2>
            <div class="align-left">
              <code class="javascript small block fragment">
function await(argument) {














}</code>
            </div>
          </section>

          <section>
            <h2>How might these magical functions be implemented?</h2>
            <div class="align-left">
              <code class="javascript small block">
function await(argument) {
  var fiber = Fiber.current;













}</code>
            </div>
          </section>

          <section>
            <h2>How might these magical functions be implemented?</h2>
            <div class="align-left">
              <code class="javascript small block">
function await(argument) {
  var fiber = Fiber.current;

  assert.ok(
    fiber instanceof Fiber,
    "Cannot await without a Fiber"
  );








}</code>
            </div>
          </section>

          <section>
            <h2>How might these magical functions be implemented?</h2>
            <div class="align-left">
              <code class="javascript small block">
function await(argument) {
  var fiber = Fiber.current;

  assert.ok(
    fiber instanceof Fiber,
    "Cannot await without a Fiber"
  );







  return Fiber.yield();
}</code>
            </div>
          </section>

          <section>
            <h2>How might these magical functions be implemented?</h2>
            <div class="align-left">
              <code class="javascript small block">
function await(argument) {
  var fiber = Fiber.current;

  assert.ok(
    fiber instanceof Fiber,
    "Cannot await without a Fiber"
  );

  Promise.resolve(argument)





  return Fiber.yield();
}</code>
            </div>
          </section>

          <section>
            <h2>How might these magical functions be implemented?</h2>
            <div class="align-left">
              <code class="javascript small block">
function await(argument) {
  var fiber = Fiber.current;

  assert.ok(
    fiber instanceof Fiber,
    "Cannot await without a Fiber"
  );

  Promise.resolve(argument).then(function (result) {

  }, function (error) {

  });

  return Fiber.yield();
}</code>
            </div>
          </section>

          <section>
            <h2>How might these magical functions be implemented?</h2>
            <div class="align-left">
              <code class="javascript small block">
function await(argument) {
  var fiber = Fiber.current;

  assert.ok(
    fiber instanceof Fiber,
    "Cannot await without a Fiber"
  );

  Promise.resolve(argument).then(function (result) {
    fiber.run(result);
  }, function (error) {

  });

  return Fiber.yield();
}</code>
            </div>
          </section>

          <section>
            <h2>How might these magical functions be implemented?</h2>
            <div class="align-left">
              <code class="javascript small block">
function await(argument) {
  var fiber = Fiber.current;

  assert.ok(
    fiber instanceof Fiber,
    "Cannot await without a Fiber"
  );

  Promise.resolve(argument).then(function (result) {
    fiber.run(result);
  }, function (error) {
    fiber.throwInto(error);
  });

  return Fiber.yield();
}</code>
            </div>
          </section>

          <section>
            <h2>How might these magical functions be implemented?</h2>
            <div class="align-left">
              <code class="javascript small block">
function async(fn) {














}</code>
            </div>
          </section>

          <section>
            <h2>How might these magical functions be implemented?</h2>
            <div class="align-left">
              <code class="javascript small block">
function async(fn) {
  return function () {












  };
}</code>
            </div>
          </section>

          <section>
            <h2>How might these magical functions be implemented?</h2>
            <div class="align-left">
              <code class="javascript small block">
function async(fn) {
  return function () {
    var self = this;
    var args = arguments;










  };
}</code>
            </div>
          </section>

          <section>
            <h2>How might these magical functions be implemented?</h2>
            <div class="align-left">
              <code class="javascript small block">
function async(fn) {
  return function () {
    var self = this;
    var args = arguments;

    return new Promise(function (resolve, reject) {







    });
  };
}</code>
            </div>
          </section>

          <section>
            <h2>How might these magical functions be implemented?</h2>
            <div class="align-left">
              <code class="javascript small block">
function async(fn) {
  return function () {
    var self = this;
    var args = arguments;

    return new Promise(function (resolve, reject) {
      new Fiber(function () {





      })
    });
  };
}</code>
            </div>
          </section>

          <section>
            <h2>How might these magical functions be implemented?</h2>
            <div class="align-left">
              <code class="javascript small block">
function async(fn) {
  return function () {
    var self = this;
    var args = arguments;

    return new Promise(function (resolve, reject) {
      new Fiber(function () {

                  fn.apply(self, args)



      })
    });
  };
}</code>
            </div>
          </section>

          <section>
            <h2>How might these magical functions be implemented?</h2>
            <div class="align-left">
              <code class="javascript small block">
function async(fn) {
  return function () {
    var self = this;
    var args = arguments;

    return new Promise(function (resolve, reject) {
      new Fiber(function () {

          resolve(fn.apply(self, args));



      })
    });
  };
}</code>
            </div>
          </section>

          <section>
            <h2>How might these magical functions be implemented?</h2>
            <div class="align-left">
              <code class="javascript small block">
function async(fn) {
  return function () {
    var self = this;
    var args = arguments;

    return new Promise(function (resolve, reject) {
      new Fiber(function () {
        try {
          resolve(fn.apply(self, args));
        } catch (error) {

        }
      })
    });
  };
}</code>
            </div>
          </section>

          <section>
            <h2>How might these magical functions be implemented?</h2>
            <div class="align-left">
              <code class="javascript small block">
function async(fn) {
  return function () {
    var self = this;
    var args = arguments;

    return new Promise(function (resolve, reject) {
      new Fiber(function () {
        try {
          resolve(fn.apply(self, args));
        } catch (error) {
          reject(error);
        }
      })
    });
  };
}</code>
            </div>
          </section>

          <section>
            <h2>How might these magical functions be implemented?</h2>
            <div class="align-left">
              <code class="javascript small block">
function async(fn) {
  return function () {
    var self = this;
    var args = arguments;

    return new Promise(function (resolve, reject) {
      new Fiber(function () {
        try {
          resolve(fn.apply(self, args));
        } catch (error) {
          reject(error);
        }
      }).run();
    });
  };
}</code>
            </div>
          </section>
        </section>

        <section>
          <h2>
            Once we have these two functions in our
            toolchain,<span class="fragment"> we can forget they were
            implemented
            using <code class="javascript">Fiber</code>s!</span>
          </h2>
        </section>

        <section>
          <section>
            <h2>
              These two functions are more powerful than they seem.
            </h2>
            <div class="align-left">
              <code class="javascript small block fragment">
let createUser = async(function (name) {
  let response = await(users.insert({ name: name }));
  return await(users.findOne(response._id));
});

let getOrCreateUser = async(function (name) {
  let user = await(users.findOne({ name: name }));
  return user || await(createUser(name));
});</code>
            </div>
            <p class="fragment">
              How many of these function calls are really necessary?
              Let's try removing some...
            </p>
          </section>

          <section>
            <h2>
              These two functions are more powerful than they seem.
            </h2>
            <div class="align-left">
              <code class="javascript small block">
function createUser(name) {
  let response = await(users.insert({ name: name }));
  return await(users.findOne(response._id));
}

let getOrCreateUser = async(function (name) {
  let user = await(users.findOne({ name: name }));
  return user || await(createUser(name));
});</code>
            </div>
            <p>
              Those <code class="javascript">await</code> calls
              in <code class="javascript">createUser</code> are legal as
              long as some <code class="javascript">async</code> function
              is on the call stack.
            </p>
          </section>

          <section>
            <h2>
              These two functions are more powerful than they seem.
            </h2>
            <div class="align-left">
              <code class="javascript small block">
function createUser(name) {
  let response = await(users.insert({ name: name }));
  return await(users.findOne(response._id));
}

let getOrCreateUser = async(function (name) {
  let user = await(users.findOne({ name: name }));
  return user || createUser(name);
});</code>
            </div>
            <p>
              Since <code class="javascript">createUser</code> no longer
              returns a <code class="javascript">Promise</code>,
              <code class="javascript">getOrCreateUser</code> no longer
              needs to <code class="javascript">await</code> it.
            </p>
          </section>

          <section>
            <h2>
              These two functions are more powerful than they seem.
            </h2>
            <div class="align-left">
              <code class="javascript small block">
function createUser(name) {
  let response = await(users.insert({ name: name }));
  return await(users.findOne(response._id));
}

let getOrCreateUser = async(function (name) {
  let user = await(users.findOne({ name: name }));
  return user || createUser(name);
});</code>
            </div>
            <p>
              In fact, if you're willing to adopt the practice of running
              all your code in a <code class="javascript">Fiber</code>...
            </p>
          </section>

          <section>
            <h2>
              These two functions are more powerful than they seem.
            </h2>
            <div class="align-left">
              <code class="javascript small block">
function createUser(name) {
  let response = await(users.insert({ name: name }));
  return await(users.findOne(response._id));
}

function getOrCreateUser(name) {
  let user = await(users.findOne({ name: name }));
  return user || createUser(name);
}</code>
            </div>
            <p>
              ... you don't even necessarily have to
              wrap <code class="javascript">getOrCreateUser</code> as
              an <code class="javascript">async</code> function!
            </p>
          </section>

          <section>
            <h2>
              These two functions are more powerful than they seem.
            </h2>
            <div class="align-left">
              <code class="javascript small block">
function createUser(name) {
  let response = await(users.insert({ name: name }));
  return await(users.findOne(response._id));
}

function getOrCreateUser(name) {
  let user = await(users.findOne({ name: name }));
  return user || createUser(name);
}</code>
            </div>
            <p>
              In this coding style,
              the <code class="javascript">await</code> function becomes a
              tool for evaluating promises &ldquo;synchronously.&rdquo;
            </p>
          </section>
        </section>

        <section>
          <h2>
            It can still be valuable to mark functions
            as <code class="javascript">async</code>, so that they can run
            in parallel.
          </h2>
          <code class="javascript block fragment">
let [ben, marley] = await Promise.all([
  getOrCreateUser("ben"),
  getOrCreateUser("marley")
]);
          </code>
          <p class="fragment">
            If <code class="javascript">getOrCreateUser</code>
            is <code class="javascript">async</code>, then it returns
            a <code class="javascript">Promise</code>, so
            <code class="javascript">marley</code> need not wait for
            <code class="javascript">ben</code>.
          </p>
        </section>

        <section class="fixed-height">
          <h2>
            How does Meteor allow<br>
            database access on the client?
          </h2>
          <br>
          <p class="fragment">
            <a target="_blank"
               href="https://www.meteor.com/mini-databases"><b>Minimongo</b></a>
               is essentially a sophisticated cache that supports a subset
               of the <code class="javascript">MongoCollection</code> API
               (<code class="javascript">.find</code>,
            <code class="javascript">.findOne</code>,
            <code class="javascript">.insert</code>,
            <code class="javascript">.update</code>,
            <code class="javascript">.remove</code>).
          </p>
          <p class="fragment">
            These operations have to return
            immediately,<span class="fragment"> and sometimes no results
            are available the first time!</span>
          </p>
          <p class="fragment">
            Acceptable because Meteor automatically rerenders the UI
            whenever different data become available.
          </p>
        </section>

        <section class="fixed-height">
          <h2>
            How should Meteor allow<br>
            database access on the client?
          </h2>
          <br>
          <p class="fragment">
            If we wanted the database access API on the client to work
            like the one on the server,<span class="fragment"> we could
            rewrite both to
            return <code class="javascript">Promise</code> objects.</span>
          </p>
          <p class="fragment">
            Now that <code class="javascript">Promise</code>s are baked
            into ES6, most new asynchronous APIs should be written in that
            style.
          </p>
          <p class="fragment">
            You could then think of <code class="javascript">await</code>
            merely as a convenience that happens to be available on the
            server.
          </p>
        </section>

        <section class="fixed-height">
          <h1>Summary</h1>
          <br>
          <p class="fragment">
            Coroutines are a <em>relaxation</em> of
            ES7 <code class="javascript">async</code>
            and <code class="javascript">await</code>
            syntax,<span class="fragment"> in which
            <code class="javascript">await</code> is allowed to appear in
            the body of any function called within
            a <code class="javascript">Fiber</code>,<span class="fragment">
            instead of being restricted to the bodies of functions that
            are explicitly marked
            <code class="javascript">async</code>.
            </span></span>
          </p>
          <!-- TODO Show createUser and sleep with relaxed await -->
        </section>

        <section class="fixed-height">
          <h1>Summary</h1>
          <br>
          <code class="javascript small block fragment">
async function createUser(name) {
  let response = await users.insert({ name: name });
  return await users.findOne(response._id);
}

async function getOrCreateUser(name) {
  let user = await users.findOne({ name: name });
  return user || await createUser(name);
}</code>
        </section>

        <section class="fixed-height">
          <h1>Summary</h1>
          <br>
          <code class="javascript small block">
      function createUser(name) {
  let response = await users.insert({ name: name });
  return await users.findOne(response._id);
}

      function getOrCreateUser(name) {
  let user = await users.findOne({ name: name });
  return user ||       createUser(name);
}</code>
        </section>

        <section class="fixed-height">
          <h1>Summary</h1>
          <br>
          <code class="javascript small block">
function createUser(name) {
  let response = await users.insert({ name: name });
  return await users.findOne(response._id);
}

function getOrCreateUser(name) {
  let user = await users.findOne({ name: name });
  return user || createUser(name);
}


          </code>
          <p class="fragment">
            This future is possible.
          </p>
        </section>

        <section class="fixed-height">
          <h1>Summary</h1>
          <br>
          <p class="fragment">
            This is great news for a framework like
            Meteor,<span class="fragment"> because we can wrap our
            top-level request and event handlers
            in <code class="javascript">Fiber</code>s<span class="fragment">,
            then use <code class="javascript">await</code> to implement
            certain asynchronous library
            operations,<span class="fragment"> and <b>none of the code in
            between has to know about coroutines at
            all.</b></span></span></span>
          </p>
        </section>

        <section class="fixed-height">
          <h1>Summary</h1>
          <br>
          <p class="fragment">
            Best of all,<span class="fragment"> the adoption of
            ES7 <code class="javascript">async</code>
            and <code class="javascript">await</code> means TC39 will not
            have to invent any new syntax if we ever decide to adopt
            coroutines,<span class="fragment"> because anything you might
            want to do with coroutines can be expressed in terms
            of <code class="javascript">async</code>
            and <code class="javascript">await</code>,<span class="fragment">
            just with slightly relaxed rules about
            where <code class="javascript">await</code> can legally
            appear.</span></span></span>
          </p>
        </section>

        <section>
          <h1>There has to be a catch, right?</h1>
        </section>

        <section>
          <h2>
            Catch #1:<span class="fragment">
              Simulating <code class="javascript">Fiber</code>s in the
              browser is difficult.</span>
          </h2>
          <br>
          <p class="fragment">
            For a framework that strives to be isomorphic, this
            inconsistency is unfortunate.
          </p>
        </section>

        <section>
          <h2>
            Could we implement <code class="javascript">Fiber</code>s
            using ES7 <code class="javascript">async</code> and
            <code class="javascript">await</code>?
          </h2>
          <p class="fragment">
            Technically yes,<span class="fragment"> though it would
            require <code class="javascript">await</code>ing any
            expression that might possibly evaluate to
            a <code class="javascript">Promise</code>.</span>
          </p>
          <p class="fragment">
            Any function containing
            an <code class="javascript">await</code> expression would have
            to become an <code class="javascript">async</code> function.
          </p>
          <p class="fragment">
            The results of all those
            new <code class="javascript">async</code> functions would have
            to be <code class="javascript">await</code>ed, and so on.
          </p>
          <p class="fragment">
            Without strong type inference, nearly every function in your
            codebase would become <code class="javascript">async</code>.
          </p>
        </section>

        <section class="fixed-height">
          <h2>And why would that be bad?</h2>
          <table class="side-by-side">
            <tbody>
              <tr>
                <td><code class="javascript small block fragment">
async function createUser(name) {
  var response = await users.insert({ name: name });
  return await users.findOne(response._id);
}</code></td>
                <td><code class="javascript small block fragment">
async function getOrCreateUser(name) {
  var user = await users.findOne({ name: name });
  return user || await createUser(name);
}</code></td>
              </tr>
            </tbody>
          </table>
        </section>

        <section class="fixed-height">
          <h2>And why would that be bad?</h2>
          <table class="side-by-side">
            <tbody>
              <tr>
                <td><code class="javascript very-small block">
function createUser(name) {
  var response;

  return regeneratorRuntime.async(function (context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
    case 0:
      context$1$0.next = 2;
      return users.insert({ name: name });
    case 2:
      response = context$1$0.sent;
      context$1$0.next = 5;
      return users.findOne(response._id);
    case 5:
      return context$1$0.abrupt("return", context$1$0.sent);
    case 6:
    case "end":
      return context$1$0.stop();
    }
  }, null, this);
}</code></td>
                <td><code class="javascript small block">
async function getOrCreateUser(name) {
  var user = await users.findOne({ name: name });
  return user || await createUser(name);
}</code></td>
              </tr>
            </tbody>
          </table>
        </section>

        <section class="fixed-height">
          <h2>And why would that be bad?</h2>
          <table class="side-by-side">
            <tbody>
              <tr>
                <td><code class="javascript very-small block">
function createUser(name) {
  var response;

  return regeneratorRuntime.async(function (context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
    case 0:
      context$1$0.next = 2;
      return users.insert({ name: name });
    case 2:
      response = context$1$0.sent;
      context$1$0.next = 5;
      return users.findOne(response._id);
    case 5:
      return context$1$0.abrupt("return", context$1$0.sent);
    case 6:
    case "end":
      return context$1$0.stop();
    }
  }, null, this);
}</code></td>
                <td><code class="javascript very-small block">
function getOrCreateUser(name) {
  var user;

  return regeneratorRuntime.async(function (context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
    case 0:
      context$1$0.next = 2;
      return users.findOne({ name: name });
    case 2:
      user = context$1$0.sent;
      context$1$0.t1 = user;
      if (context$1$0.t1) {
        context$1$0.next = 8;
        break;
      }
      context$1$0.next = 7;
      return createUser(name);
    case 7:
      context$1$0.t1 = context$1$0.sent;
    case 8:
      return context$1$0.abrupt("return", context$1$0.t1);
    case 9:
    case "end":
      return context$1$0.stop();
    }
  }, null, this);
}</code></td>
              </tr>
            </tbody>
          </table>
        </section>

        <section class="fixed-height">
          <h2>And why would that be bad?</h2>
          <div class="align-left">
            <code class="javascript small block fragment">
async function createUser(name) {
  var response = await users.insert({ name: name });
  return await users.findOne(response._id);
}</code>
          </div>
        </section>

        <section class="fixed-height">
          <h2>And why would that be bad?</h2>
          <div class="align-left">
            <code class="javascript small block">
async function createUser(name) {
  var response = await (await users).insert({ name: await name });
  return await (await users).findOne(await response._id);
}</code>
          </div>
        </section>

        <section class="fixed-height">
          <h2>And why would that be bad?</h2>
          <table class="side-by-side">
            <tbody>
              <tr>
                <td><code class="javascript very-small block">
function createUser(name) {
  var response;

  return regeneratorRuntime.async(function (context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
    case 0:
      context$1$0.next = 2;
      return users;
    case 2:
      context$1$0.next = 4;
      return name;
    case 4:
      context$1$0.t0 = context$1$0.sent;
      context$1$0.next = 7;

      return context$1$0.sent.insert({
        name: context$1$0.t0
      });
</code></td>
                <td><code class="javascript very-small block fragment">





    case 7:
      response = context$1$0.sent;
      context$1$0.next = 10;
      return users;
    case 10:
      context$1$0.next = 12;
      return response._id;
    case 12:
      context$1$0.t1 = context$1$0.sent;
      context$1$0.next = 15;
      return context$1$0.sent.findOne(context$1$0.t1);
    case 15:
      return context$1$0.abrupt("return", context$1$0.sent);
    case 16:
    case "end":
      return context$1$0.stop();
    }
  }, null, this);
}</code></td>
              </tr>
            </tbody>
          </table>
        </section>

        <section>
          <h2>
            Catch #2:<span class="fragment">
              Mutating shared global state is tricky
              with <code class="javascript">Fiber</code>s
            </span>
          </h2>
          <br>
          <p class="fragment">
            Minimizing the use of mutable shared global state is a good
            idea in general, of course.
          </p>
          <p class="fragment">
            One particular instance of shared global state that may be
            difficult to avoid:<span class="fragment"> the <b>file
            system</b>.</span>
          </p>
        </section>

        <section>
          <h2>
            How we write safe file system code
            with <code class="javascript">Fiber</code>s
          </h2>
          <p class="fragment">
            <code class="javascript small block">
fiberHelpers.noYieldsAllowed(function () {
  // Any calls to Fiber.yield will throw.
});</code>
          </p>
          <p class="fragment">
            This could be improved by restricting what kind of events can
            run while the current <code class="javascript">Fiber</code> is
            yielding, rather than preventing the
            <code class="javascript">Fiber</code> from yielding at all.
          </p>
          <p class="fragment">
            We also wrap the functions in Node's <code>fs</code> module to
            be asynchronous when
            <code class="javascript">Fiber.current</code> is defined and
            synchronous otherwise.
          </p>
        </section>

        <section>
          <h2>
            Catch #3:<span class="fragment"> Ensuring compatibility
              with <code class="javascript">Fiber</code>s is a
              burden.</span>
          </h2>
          <br>
          <p class="fragment">
            Other native modules might not work well
            with <code class="javascript">Fiber</code>s.
          </p>
          <p class="fragment">
            Our ability to keep up-to-date with the latest Node could be
            impeded by changes to its native module API.
          </p>
          <p class="fragment">
            Fortunately we have plenty of warning, and we ship specific
            versions of Node and all our packages.
          </p>
        </section>

        <section>
          <h2>
            For Meteor, the benefits are clear:
          </h2>
          <br>
          <ul>
            <li class="fragment"><h3>Learnability</h3></li>
            <li class="fragment"><h3>Maintainability</h3></li>
            <li class="fragment"><h3>Flexibility</h3></li>
          </ul>
        </section>

        <section data-background="img/wires.jpg">
          <h1 class="thanks">Thanks!</h1>
        </section>

        <section data-background="img/goto/end.png"
                 data-background-size="70%">
        </section>
      </div>
    </div>

    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.js"></script>
    <script src="js/init.js"></script>
  </body>
</html>
